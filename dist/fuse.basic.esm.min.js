/**
 * Fuse.js v6.1.0-alpha.2 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
function e(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}function t(e){return"string"==typeof e}function n(e){return"number"==typeof e}function s(e){return null!=e}function i(e){return!e.trim().length}const r=Object.prototype.hasOwnProperty;class o{constructor(e){this._keys={},this._keyNames=[];let n=0;e.forEach(e=>{let s,i=1;if(t(e))s=e;else{if(!r.call(e,"name"))throw new Error(`Missing ${"name"} property in key`);if(s=e.name,r.call(e,"weight")&&(i=e.weight,i<=0))throw new Error((e=>`Property 'weight' in key '${e}' must be a positive integer`)(s))}this._keyNames.push(s),this._keys[s]={weight:i},n+=i}),this._keyNames.forEach(e=>{this._keys[e].weight/=n})}get(e,t){return this._keys[e]&&this._keys[e][t]}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}var c={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(i,r){let o=[],c=!1;const h=(i,r)=>{if(r){const a=r.indexOf(".");let l=r,d=null;-1!==a&&(l=r.slice(0,a),d=r.slice(a+1));const u=i[l];if(!s(u))return;if(d||!t(u)&&!n(u))if(e(u)){c=!0;for(let e=0,t=u.length;e<t;e+=1)h(u[e],d)}else d&&h(u,d);else o.push(function(e){return null==e?"":function(e){if("string"==typeof e)return e;let t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)}(u))}else o.push(i)};return h(i,r),c?o:o[0]},ignoreLocation:!1,ignoreFieldNorm:!1,returnAllWhenEmpty:!1}};const h=/[^ ]+/g;class a{constructor({getFn:e=c.getFn}={}){this.norm=function(e=3){const t=new Map;return{get(n){const s=n.match(h).length;if(t.has(s))return t.get(s);const i=parseFloat((1/Math.sqrt(s)).toFixed(e));return t.set(s,i),i},clear(){t.clear()}}}(3),this.getFn=e,this.isCreated=!1,this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e}create(){!this.isCreated&&this.docs.length&&(this.isCreated=!0,t(this.docs[0])?this.docs.forEach((e,t)=>{this._addString(e,t)}):this.docs.forEach((e,t)=>{this._addObject(e,t)}),this.norm.clear())}add(e){const n=this.size();t(e)?this._addString(e,n):this._addObject(e,n)}removeAt(e){this.records.splice(e,1);for(let t=e,n=this.size();t<n;t+=1)this.records[t].i-=1}size(){return this.records.length}_addString(e,t){if(!s(e)||i(e))return;let n={v:e,i:t,n:this.norm.get(e)};this.records.push(n)}_addObject(n,r){let o={i:r,$:{}};this.keys.forEach((r,c)=>{let h=this.getFn(n,r);if(s(h))if(e(h)){let n=[];const r=[{nestedArrIndex:-1,value:h}];for(;r.length;){const{nestedArrIndex:o,value:c}=r.pop();if(s(c))if(t(c)&&!i(c)){let e={v:c,i:o,n:this.norm.get(c)};n.push(e)}else e(c)&&c.forEach((e,t)=>{r.push({nestedArrIndex:t,value:e})})}o.$[c]=n}else if(!i(h)){let e={v:h,n:this.norm.get(h)};o.$[c]=e}}),this.records.push(o)}toJSON(){return{keys:this.keys,records:this.records}}}function l(e,t,{getFn:n=c.getFn}={}){let s=new a({getFn:n});return s.setKeys(e),s.setSources(t),s.create(),s}function d(e,t){const n=e.matches;t.matches=[],s(n)&&n.forEach(e=>{if(!s(e.indices)||!e.indices.length)return;const{indices:n,value:i}=e;let r={indices:n,value:i};e.key&&(r.key=e.key),e.idx>-1&&(r.refIndex=e.idx),t.matches.push(r)})}function u(e,t){t.score=e.score}function f(e,{errors:t=0,currentLocation:n=0,expectedLocation:s=0,distance:i=c.distance,ignoreLocation:r=c.ignoreLocation}={}){const o=t/e.length;if(r)return o;const h=Math.abs(s-n);return i?o+h/i:h?1:o}function g(e,t,n,{location:s=c.location,distance:i=c.distance,threshold:r=c.threshold,findAllMatches:o=c.findAllMatches,minMatchCharLength:h=c.minMatchCharLength,includeMatches:a=c.includeMatches,ignoreLocation:l=c.ignoreLocation}={}){if(t.length>32)throw new Error(`Pattern length exceeds max of ${32}.`);const d=t.length,u=e.length,g=Math.max(0,Math.min(s,u));let p=r,m=g;const y=[];if(a)for(let e=0;e<u;e+=1)y[e]=0;let M;for(;(M=e.indexOf(t,m))>-1;){let e=f(t,{currentLocation:M,expectedLocation:g,distance:i,ignoreLocation:l});if(p=Math.min(e,p),m=M+d,a){let e=0;for(;e<d;)y[M+e]=1,e+=1}}m=-1;let x=[],L=1,_=d+u;const k=1<<d-1;for(let s=0;s<d;s+=1){let r=0,c=_;for(;r<c;){f(t,{errors:s,currentLocation:g+c,expectedLocation:g,distance:i,ignoreLocation:l})<=p?r=c:_=c,c=Math.floor((_-r)/2+r)}_=c;let h=Math.max(1,g-c+1),M=o?u:Math.min(g+c,u)+d,v=Array(M+2);v[M+1]=(1<<s)-1;for(let r=M;r>=h;r-=1){let o=r-1,c=n[e.charAt(o)];if(c&&a&&(y[o]=1),v[r]=(v[r+1]<<1|1)&c,0!==s&&(v[r]|=(x[r+1]|x[r])<<1|1|x[r+1]),v[r]&k&&(L=f(t,{errors:s,currentLocation:o,expectedLocation:g,distance:i,ignoreLocation:l}),L<=p)){if(p=L,m=o,m<=g)break;h=Math.max(1,2*g-m)}}if(f(t,{errors:s+1,currentLocation:g,expectedLocation:g,distance:i,ignoreLocation:l})>p)break;x=v}let v={isMatch:m>=0,score:Math.max(.001,L)};return a&&(v.indices=function(e=[],t=c.minMatchCharLength){let n=[],s=-1,i=-1,r=0;for(let o=e.length;r<o;r+=1){let o=e[r];o&&-1===s?s=r:o||-1===s||(i=r-1,i-s+1>=t&&n.push([s,i]),s=-1)}return e[r-1]&&r-s>=t&&n.push([s,r-1]),n}(y,h)),v}function p(e){let t={};for(let n=0,s=e.length;n<s;n+=1){const i=e.charAt(n);t[i]=(t[i]||0)|1<<s-n-1}return t}class m{constructor(e,{location:t=c.location,threshold:n=c.threshold,distance:s=c.distance,includeMatches:i=c.includeMatches,findAllMatches:r=c.findAllMatches,minMatchCharLength:o=c.minMatchCharLength,isCaseSensitive:h=c.isCaseSensitive,ignoreLocation:a=c.ignoreLocation}={}){if(this.options={location:t,threshold:n,distance:s,includeMatches:i,findAllMatches:r,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a},this.pattern=h?e:e.toLowerCase(),this.chunks=[],!this.pattern.length)return;const l=(e,t)=>{this.chunks.push({pattern:e,alphabet:p(e),startIndex:t})},d=this.pattern.length;if(d>32){let e=0;const t=d%32,n=d-t;for(;e<n;)l(this.pattern.substr(e,32),e),e+=32;if(t){const e=d-32;l(this.pattern.substr(e),e)}}else l(this.pattern,0)}searchIn(e){const{isCaseSensitive:t,includeMatches:n}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return n&&(t.indices=[[0,e.length-1]]),t}const{location:s,distance:i,threshold:r,findAllMatches:o,minMatchCharLength:c,ignoreLocation:h}=this.options;let a=[],l=0,d=!1;this.chunks.forEach(({pattern:t,alphabet:u,startIndex:f})=>{const{isMatch:p,score:m,indices:y}=g(e,t,u,{location:s+f,distance:i,threshold:r,findAllMatches:o,minMatchCharLength:c,includeMatches:n,ignoreLocation:h});p&&(d=!0),l+=m,p&&y&&(a=[...a,...y])});let u={isMatch:d,score:d?l/this.chunks.length:1};return d&&n&&(u.indices=a),u}}const y=[];function M(e,t){for(let n=0,s=y.length;n<s;n+=1){let s=y[n];if(s.condition(e,t))return new s(e,t)}return new m(e,t)}class x{constructor(e,t={},n){if(this.options={...c,...t},this.options.useExtendedSearch)throw new Error("Extended search is not available");this._keyStore=new o(this.options.keys),this.setCollection(e,n)}setCollection(e,t){if(this._docs=e,t&&!(t instanceof a))throw new Error("Incorrect 'index' type");this._myIndex=t||l(this._keyStore.keys(),this._docs,{getFn:this.options.getFn})}add(e){s(e)&&(this._docs.push(e),this._myIndex.add(e))}remove(e=(()=>!1)){const t=[];for(let n=0,s=this._docs.length;n<s;n+=1){const s=this._docs[n];e(s,n)&&(this.removeAt(n),n-=1,t.push(s))}return t}removeAt(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:r=-1}={}){const{includeMatches:o,includeScore:h,shouldSort:a,sortFn:l,ignoreFieldNorm:f,returnAllWhenEmpty:g}=this.options;if(g&&(!s(e)||i(e)))return this._docs.map((e,t)=>({item:e,score:1,refIndex:t}));let p=t(e)?t(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return function(e,t,{ignoreFieldNorm:n=c.ignoreFieldNorm}){e.forEach(e=>{let s=1;e.matches.forEach(({key:e,norm:i,score:r})=>{const o=t.get(e,"weight");s*=Math.pow(0===r&&o?Number.EPSILON:r,(o||1)*(n?1:i))}),e.score=s})}(p,this._keyStore,{ignoreFieldNorm:f}),a&&p.sort(l),n(r)&&r>-1&&(p=p.slice(0,r)),function(e,t,{includeMatches:n=c.includeMatches,includeScore:s=c.includeScore}={}){const i=[];n&&i.push(d);s&&i.push(u);return e.map(e=>{const{idx:n}=e,s={item:t[n],refIndex:n};return i.length&&i.forEach(t=>{t(e,s)}),s})}(p,this._docs,{includeMatches:o,includeScore:h})}_searchStringList(e){const t=M(e,this.options),{records:n}=this._myIndex,i=[];return n.forEach(({v:e,i:n,n:r})=>{if(!s(e))return;const{isMatch:o,score:c,indices:h}=t.searchIn(e);o&&i.push({item:e,idx:n,matches:[{score:c,value:e,norm:r,indices:h}]})}),i}_searchLogical(e){throw new Error("Logical search is not available")}_searchObjectList(e){const t=M(e,this.options),{keys:n,records:i}=this._myIndex,r=[];return i.forEach(({$:e,i:i})=>{if(!s(e))return;let o=[];n.forEach((n,s)=>{o.push(...this._findMatches({key:n,value:e[s],searcher:t}))}),o.length&&r.push({idx:i,item:e,matches:o})}),r}_findMatches({key:t,value:n,searcher:i}){if(!s(n))return[];let r=[];if(e(n))n.forEach(({v:e,i:n,n:o})=>{if(!s(e))return;const{isMatch:c,score:h,indices:a}=i.searchIn(e);c&&r.push({score:h,key:t,value:e,idx:n,norm:o,indices:a})});else{const{v:e,n:s}=n,{isMatch:o,score:c,indices:h}=i.searchIn(e);o&&r.push({score:c,key:t,value:e,norm:s,indices:h})}return r}}x.version="6.1.0-alpha.2",x.createIndex=l,x.parseIndex=function(e,{getFn:t=c.getFn}={}){const{keys:n,records:s}=e;let i=new a({getFn:t});return i.setKeys(n),i.setIndexRecords(s),i},x.config=c;export default x;