/**
 * Fuse.js v5.2.3 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
const t=t=>Array.isArray?Array.isArray(t):"[object Array]"===Object.prototype.toString.call(t),e=t=>"string"==typeof t,n=t=>"number"==typeof t,s=t=>null!=t,i=t=>!t.trim().length;var r={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(t,e)=>t.score===e.score?t.idx<e.idx?-1:1:t.score<e.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(i,r){let h=[],o=!1;const c=(i,r)=>{if(r){const l=r.indexOf(".");let a=r,u=null;-1!==l&&(a=r.slice(0,l),u=r.slice(l+1));const d=i[a];if(s(d))if(u||!e(d)&&!n(d))if(t(d)){o=!0;for(let t=0,e=d.length;t<e;t+=1)c(d[t],u)}else u&&c(d,u);else h.push((t=>null==t?"":(t=>{if("string"==typeof t)return t;let e=t+"";return"0"==e&&1/t==-1/0?"-0":e})(t))(d))}else h.push(i)};return c(i,r),o?h:h[0]}}};function h(t,{errors:e=0,currentLocation:n=0,expectedLocation:s=0,distance:i=r.distance}={}){const h=e/t.length,o=Math.abs(s-n);return i?h+o/i:o?1:h}function o(t,e,n,{location:s=r.location,distance:i=r.distance,threshold:o=r.threshold,findAllMatches:c=r.findAllMatches,minMatchCharLength:l=r.minMatchCharLength,includeMatches:a=r.includeMatches}={}){if(e.length>32)throw new Error("Pattern length exceeds max of 32.");const u=e.length,d=t.length,f=Math.max(0,Math.min(s,d));let g=o,p=f;const y=[];if(a)for(let t=0;t<d;t+=1)y[t]=0;let m;for(;(m=t.indexOf(e,p))>-1;){let t=h(e,{currentLocation:m,expectedLocation:f,distance:i});if(g=Math.min(t,g),p=m+u,a){let t=0;for(;t<u;)y[m+t]=1,t+=1}}p=-1;let M=[],k=1,x=u+d;const _=1<<(u<=31?u-1:30);for(let s=0;s<u;s+=1){let r=0,o=x;for(;r<o;){h(e,{errors:s,currentLocation:f+o,expectedLocation:f,distance:i})<=g?r=o:x=o,o=Math.floor((x-r)/2+r)}x=o;let l=Math.max(1,f-o+1),m=c?d:Math.min(f+o,d)+u,S=Array(m+2);S[m+1]=(1<<s)-1;for(let r=m;r>=l;r-=1){let o=r-1,c=n[t.charAt(o)];if(c&&a&&(y[o]=1),S[r]=(S[r+1]<<1|1)&c,0!==s&&(S[r]|=(M[r+1]|M[r])<<1|1|M[r+1]),S[r]&_&&(k=h(e,{errors:s,currentLocation:o,expectedLocation:f,distance:i}),k<=g)){if(g=k,p=o,p<=f)break;l=Math.max(1,2*f-p)}}if(h(e,{errors:s+1,currentLocation:f,expectedLocation:f,distance:i})>g)break;M=S}let S={isMatch:p>=0,score:k||.001};return a&&(S.matchedIndices=function(t=[],e=r.minMatchCharLength){let n=[],s=-1,i=-1,h=0;for(let r=t.length;h<r;h+=1){let r=t[h];r&&-1===s?s=h:r||-1===s||(i=h-1,i-s+1>=e&&n.push([s,i]),s=-1)}return t[h-1]&&h-s>=e&&n.push([s,h-1]),n}(y,l)),S}function c(t){let e={},n=t.length;for(let s=0;s<n;s+=1)e[t.charAt(s)]=0;for(let s=0;s<n;s+=1)e[t.charAt(s)]|=1<<n-s-1;return e}class l{constructor(t,{location:e=r.location,threshold:n=r.threshold,distance:s=r.distance,includeMatches:i=r.includeMatches,findAllMatches:h=r.findAllMatches,minMatchCharLength:o=r.minMatchCharLength,isCaseSensitive:l=r.isCaseSensitive}={}){this.options={location:e,threshold:n,distance:s,includeMatches:i,findAllMatches:h,minMatchCharLength:o,isCaseSensitive:l},this.pattern=l?t:t.toLowerCase(),this.chunks=[];let a=0;for(;a<this.pattern.length;){let t=this.pattern.substring(a,a+32);this.chunks.push({pattern:t,alphabet:c(t)}),a+=32}}searchIn(t){let e=t.v;return this.searchInString(e)}searchInString(t){const{isCaseSensitive:e,includeMatches:n}=this.options;if(e||(t=t.toLowerCase()),this.pattern===t){let e={isMatch:!0,score:0};return n&&(e.matchedIndices=[[0,t.length-1]]),e}const{location:s,distance:i,threshold:r,findAllMatches:h,minMatchCharLength:c}=this.options;let l=[],a=0,u=!1;for(let e=0,d=this.chunks.length;e<d;e+=1){let{pattern:d,alphabet:f}=this.chunks[e],g=o(t,d,f,{location:s+32*e,distance:i,threshold:r,findAllMatches:h,minMatchCharLength:c,includeMatches:n});const{isMatch:p,score:y,matchedIndices:m}=g;p&&(u=!0),a+=y,p&&m&&(l=[...l,...m])}let d={isMatch:u,score:u?a/this.chunks.length:1};return u&&n&&(d.matchedIndices=l),d}}const a=/[^ ]+/g;function u(n,h,{getFn:o=r.getFn}={}){let c=[],l=function(t=3){const e=new Map;return{get(n){const s=n.match(a).length;if(e.has(s))return e.get(s);const i=parseFloat((1/Math.sqrt(s)).toFixed(t));return e.set(s,i),i},clear(){e.clear()}}}(3);if(e(h[0]))for(let t=0,e=h.length;t<e;t+=1){const e=h[t];if(s(e)&&!i(e)){let n={v:e,i:t,n:l.get(e)};c.push(n)}}else{const r=n.length;for(let a=0,u=h.length;a<u;a+=1){let u=h[a],d={i:a,$:{}};for(let h=0;h<r;h+=1){let r=o(u,n[h]);if(s(r))if(t(r)){let n=[];const o=[{arrayIndex:-1,value:r}];for(;o.length;){const{arrayIndex:r,value:h}=o.pop();if(s(h))if(e(h)&&!i(h)){let t={v:h,i:r,n:l.get(h)};n.push(t)}else if(t(h))for(let t=0,e=h.length;t<e;t+=1)o.push({arrayIndex:t,value:h[t]})}d.$[h]=n}else if(!i(r)){let t={v:r,n:l.get(r)};d.$[h]=t}}c.push(d)}}return l.clear(),{keys:n,list:c}}const d=Object.prototype.hasOwnProperty;class f{constructor(t){this._keys={},this._keyNames=[];const n=t.length;if(t.length&&e(t[0]))for(let e=0;e<n;e+=1){const n=t[e];this._keys[n]={weight:1},this._keyNames.push(n)}else{let e=0;for(let s=0;s<n;s+=1){const n=t[s];let i={};if(!d.call(n,"name"))throw new Error('Missing "name" property in key object');const r=n.name;if(this._keyNames.push(r),!d.call(n,"weight"))throw new Error('Missing "weight" property in key object');const h=n.weight;if(h<=0||h>=1)throw new Error('"weight" property in key must be in the range of (0, 1)');i.weight=h,d.call(n,"threshold")&&(i.threshold=n.threshold),this._keys[r]=i,e+=h}for(let t=0;t<n;t+=1)this._keys[this._keyNames[t]].weight/=e}}get(t,e){return this._keys[t]?this._keys[t][e]:-1}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}function g(t,e){const n=t.matches;if(e.matches=[],s(n))for(let t=0,i=n.length;t<i;t+=1){let i=n[t];if(!s(i.indices)||0===i.indices.length)continue;let r={indices:i.indices,value:i.value};i.key&&(r.key=i.key),i.idx>-1&&(r.refIndex=i.idx),e.matches.push(r)}}function p(t,e){e.score=t.score}const y=[],m=new Set(["$and","$or"]);require("util");class M{constructor(t,e={},n){this.options={...r,...e},this._keyStore=new f(this.options.keys),this.setCollection(t,n)}setCollection(t,n){this._list=t,this._listIsStringArray=e(t[0]),this._index=n||u(this._keyStore.keys(),this._list,{getFn:this.options.getFn})}search(s,{limit:i=-1}={}){let r=[];const h=this.options,o=t=>{for(let e=0,n=y.length;e<n;e+=1){let n=y[e];if(n.condition(t,h))return new n(t,h)}return new l(t,h)};if(e(s)){const t=o(s);r=this._listIsStringArray?this._searchStringArrayWith(t):this._searchAllWith(t)}else{const e=n=>{const s=Object.keys(n),i=s[0];if(!t(n)&&"object"==typeof n&&!m.has(i)){const t=n[i];return{key:i,pattern:t,searcher:o(t,this.options)}}let r={children:[],operator:i};for(let i=0,h=s.length;i<h;i+=1){const h=n[s[i]];if(t(h))for(let t=0,n=h.length;t<n;t+=1)r.children.push(e(h[t]))}return r};let n=e(s);const i=t=>{if("$and"===t.operator){const e=t.children,n=[];for(let t=0,s=e.length;t<s;t+=1){let s=e[t],r=i(s);if(!r.length){n.length=0;break}n.push(...r)}return n}if("$or"===t.operator){const e=t.children,n=[];for(let t=0,s=e.length;t<s;t+=1){let s=e[t],r=i(s);r.length&&n.push(...r)}return n}return this._searchLogicalWith(t)};let h=i(n),c={};for(let t=0,e=h.length;t<e;t+=1){let e=h[t];c[e.idx]?c[e.idx].matches.push(...e.matches):(c[e.idx]=e,r.push(e))}}const{shouldSort:c,sortFn:a}=this.options;return this._computeScore(r),c&&r.sort(a),n(i)&&i>-1&&(r=r.slice(0,i)),this._format(r)}_searchStringArrayWith(t){const{list:e}=this._index,{includeMatches:n}=this.options,i=[];for(let r=0,h=e.length;r<h;r+=1){let h=e[r],{v:o,i:c,n:l}=h;if(!s(o))continue;let a=t.searchIn(h);const{isMatch:u,score:d}=a;if(!u)continue;let f={score:d,value:o,norm:l};n&&(f.indices=a.matchedIndices),i.push({item:o,idx:c,matches:[f]})}return i}_searchLogicalWith({key:t,searcher:e}){const n=[],{keys:i,list:r}=this._index,h=i.indexOf(t);for(let i=0,o=r.length;i<o;i+=1){let{$:o,i:c}=r[i];if(!s(o))continue;const l=o[h];let a=this._searchNestedWith({key:t,value:l,searcher:e});a.length&&n.push({idx:c,item:o,matches:a})}return n}_searchAllWith(t){const e=[],{keys:n,list:i}=this._index,r=i.length,h=n.length;for(let o=0;o<r;o+=1){let{$:r,i:c}=i[o];if(!s(r))continue;let l=[];for(let e=0;e<h;e+=1){const s=n[e],i=r[e];l.push(...this._searchNestedWith({key:s,value:i,searcher:t}))}l.length&&e.push({idx:c,item:r,matches:l})}return e}_searchNestedWith({key:e,value:n,searcher:i}){let r=[];if(!s(n))return r;const{includeMatches:h}=this.options;if(t(n))for(let t=0,o=n.length;t<o;t+=1){let o=n[t];const{v:c,i:l,n:a}=o;if(!s(c))continue;let u=i.searchIn(o);const{isMatch:d,score:f}=u;if(!d)continue;let g={score:f,key:e,value:c,idx:l,norm:a};h&&(g.indices=u.matchedIndices),r.push(g)}else{const{v:t,n:s}=n;let o=i.searchIn(n);const{isMatch:c,score:l}=o;if(!c)return[];let a={score:l,key:e,value:t,norm:s};h&&(a.indices=o.matchedIndices),r.push(a)}return r}_computeScore(t){for(let e=0,n=t.length;e<n;e+=1){const n=t[e],s=n.matches,i=s.length;let r=1;for(let t=0;t<i;t+=1){const e=s[t],{key:n,norm:i}=e,h=this._keyStore.get(n,"weight"),o=h>-1?h:1,c=0===e.score&&h>-1?Number.EPSILON:e.score;r*=Math.pow(c,o*i)}n.score=r}}_format(t){const e=[],{includeMatches:n,includeScore:s}=this.options;let i=[];n&&i.push(g),s&&i.push(p);for(let n=0,s=t.length;n<s;n+=1){const s=t[n],{idx:r}=s,h={item:this._list[r],refIndex:r};if(i.length)for(let t=0,e=i.length;t<e;t+=1)i[t](s,h);e.push(h)}return e}}M.version="5.2.3",M.createIndex=u,M.config=r;export default M;