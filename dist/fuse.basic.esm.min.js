/**
 * Fuse.js v5.2.3 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
const e=e=>Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e),t=e=>"string"==typeof e,s=e=>"number"==typeof e,n=e=>null!=e,i=e=>!e.trim().length;var r={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(i,r){let c=[],h=!1;const o=(i,r)=>{if(r){const a=r.indexOf(".");let l=r,u=null;-1!==a&&(l=r.slice(0,a),u=r.slice(a+1));const d=i[l];if(n(d))if(u||!t(d)&&!s(d))if(e(d)){h=!0;for(let e=0,t=d.length;e<t;e+=1)o(d[e],u)}else u&&o(d,u);else c.push((e=>null==e?"":(e=>{if("string"==typeof e)return e;let t=e+"";return"0"==t&&1/e==-1/0?"-0":t})(e))(d))}else c.push(i)};return o(i,r),h?c:c[0]}}};const c=/[^ ]+/g;function h(s,h,{getFn:o=r.getFn}={}){let a=[],l=function(e=3){const t=new Map;return{get(s){const n=s.match(c).length;if(t.has(n))return t.get(n);const i=parseFloat((1/Math.sqrt(n)).toFixed(e));return t.set(n,i),i},clear(){t.clear()}}}(3);return t(h[0])?h.forEach((e,t)=>{if(!n(e)||i(e))return;let s={v:e,i:t,n:l.get(e)};a.push(s)}):h.forEach((r,c)=>{let h={i:c,$:{}};s.forEach((s,c)=>{let a=o(r,s);if(n(a))if(e(a)){let s=[];const r=[{nestedArrIndex:-1,value:a}];for(;r.length;){const{nestedArrIndex:c,value:h}=r.pop();if(n(h))if(t(h)&&!i(h)){let e={v:h,i:c,n:l.get(h)};s.push(e)}else e(h)&&h.forEach((e,t)=>{r.push({nestedArrIndex:t,value:e})})}h.$[c]=s}else if(!i(a)){let e={v:a,n:l.get(a)};h.$[c]=e}}),a.push(h)}),l.clear(),{keys:s,list:a}}const o=Object.prototype.hasOwnProperty;class a{constructor(e){this._keys={},this._keyNames=[];const s=e.length;if(e.length&&t(e[0]))for(let t=0;t<s;t+=1){const s=e[t];this._keys[s]={weight:1},this._keyNames.push(s)}else{let t=0;for(let n=0;n<s;n+=1){const s=e[n];let i={};if(!o.call(s,"name"))throw new Error('Missing "name" property in key object');const r=s.name;if(this._keyNames.push(r),!o.call(s,"weight"))throw new Error('Missing "weight" property in key object');const c=s.weight;if(c<=0||c>=1)throw new Error('"weight" property in key must be in the range of (0, 1)');i.weight=c,o.call(s,"threshold")&&(i.threshold=s.threshold),this._keys[r]=i,t+=c}for(let e=0;e<s;e+=1)this._keys[this._keyNames[e]].weight/=t}}get(e,t){return this._keys[e]&&this._keys[e][t]}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}function l(e,t){const s=e.matches;if(t.matches=[],n(s))for(let e=0,i=s.length;e<i;e+=1){let i=s[e];if(!n(i.indices)||0===i.indices.length)continue;const{indices:r,value:c}=i;let h={indices:r,value:c};i.key&&(h.key=i.key),i.idx>-1&&(h.refIndex=i.idx),t.matches.push(h)}}function u(e,t){t.score=e.score}function d(e,{errors:t=0,currentLocation:s=0,expectedLocation:n=0,distance:i=r.distance}={}){const c=t/e.length,h=Math.abs(n-s);return i?c+h/i:h?1:c}function f(e,t,s,{location:n=r.location,distance:i=r.distance,threshold:c=r.threshold,findAllMatches:h=r.findAllMatches,minMatchCharLength:o=r.minMatchCharLength,includeMatches:a=r.includeMatches}={}){if(t.length>32)throw new Error("Pattern length exceeds max of 32.");const l=t.length,u=e.length,f=Math.max(0,Math.min(n,u));let p=c,g=f;const m=[];if(a)for(let e=0;e<u;e+=1)m[e]=0;let y;for(;(y=e.indexOf(t,g))>-1;){let e=d(t,{currentLocation:y,expectedLocation:f,distance:i});if(p=Math.min(e,p),g=y+l,a){let e=0;for(;e<l;)m[y+e]=1,e+=1}}g=-1;let M=[],k=1,x=l+u;const _=1<<(l<=31?l-1:30);for(let n=0;n<l;n+=1){let r=0,c=x;for(;r<c;){d(t,{errors:n,currentLocation:f+c,expectedLocation:f,distance:i})<=p?r=c:x=c,c=Math.floor((x-r)/2+r)}x=c;let o=Math.max(1,f-c+1),y=h?u:Math.min(f+c,u)+l,A=Array(y+2);A[y+1]=(1<<n)-1;for(let r=y;r>=o;r-=1){let c=r-1,h=s[e.charAt(c)];if(h&&a&&(m[c]=1),A[r]=(A[r+1]<<1|1)&h,0!==n&&(A[r]|=(M[r+1]|M[r])<<1|1|M[r+1]),A[r]&_&&(k=d(t,{errors:n,currentLocation:c,expectedLocation:f,distance:i}),k<=p)){if(p=k,g=c,g<=f)break;o=Math.max(1,2*f-g)}}if(d(t,{errors:n+1,currentLocation:f,expectedLocation:f,distance:i})>p)break;M=A}let A={isMatch:g>=0,score:k||.001};return a&&(A.matchedIndices=function(e=[],t=r.minMatchCharLength){let s=[],n=-1,i=-1,c=0;for(let r=e.length;c<r;c+=1){let r=e[c];r&&-1===n?n=c:r||-1===n||(i=c-1,i-n+1>=t&&s.push([n,i]),n=-1)}return e[c-1]&&c-n>=t&&s.push([n,c-1]),s}(m,o)),A}function p(e){let t={},s=e.length;for(let n=0;n<s;n+=1)t[e.charAt(n)]=0;for(let n=0;n<s;n+=1)t[e.charAt(n)]|=1<<s-n-1;return t}class g{constructor(e,{location:t=r.location,threshold:s=r.threshold,distance:n=r.distance,includeMatches:i=r.includeMatches,findAllMatches:c=r.findAllMatches,minMatchCharLength:h=r.minMatchCharLength,isCaseSensitive:o=r.isCaseSensitive}={}){this.options={location:t,threshold:s,distance:n,includeMatches:i,findAllMatches:c,minMatchCharLength:h,isCaseSensitive:o},this.pattern=o?e:e.toLowerCase(),this.chunks=[];let a=0;for(;a<this.pattern.length;){let e=this.pattern.substring(a,a+32);this.chunks.push({pattern:e,alphabet:p(e)}),a+=32}}searchIn(e){let t=e.v;return this.searchInString(t)}searchInString(e){const{isCaseSensitive:t,includeMatches:s}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return s&&(t.matchedIndices=[[0,e.length-1]]),t}const{location:n,distance:i,threshold:r,findAllMatches:c,minMatchCharLength:h}=this.options;let o=[],a=0,l=!1;for(let t=0,u=this.chunks.length;t<u;t+=1){let{pattern:u,alphabet:d}=this.chunks[t],p=f(e,u,d,{location:n+32*t,distance:i,threshold:r,findAllMatches:c,minMatchCharLength:h,includeMatches:s});const{isMatch:g,score:m,matchedIndices:y}=p;g&&(l=!0),a+=m,g&&y&&(o=[...o,...y])}let u={isMatch:l,score:l?a/this.chunks.length:1};return l&&s&&(u.matchedIndices=o),u}}const m=[];function y(e,t){for(let s=0,n=m.length;s<n;s+=1){let n=m[s];if(n.condition(e,t))return new n(e,t)}return new g(e,t)}const M={AND:"$and",OR:"$or"},k=new Set(Object.values(M));class x{constructor(e,t={},s){this.options={...r,...t},this._keyStore=new a(this.options.keys),this.setCollection(e,s)}setCollection(e,t){this._list=e,this._index=t||h(this._keyStore.keys(),this._list,{getFn:this.options.getFn})}search(i,{limit:c=-1}={}){let h=[];const{includeMatches:o,includeScore:a,shouldSort:d,sortFn:f}=this.options;if(t(i)){const e=y(i,this.options);h=t(this._list[0])?this._searchStringArrayWith(e):this._searchAllWith(e)}else{let t=function(t,s){const n=t=>{const i=Object.keys(t),r=i[0];if(!e(t)&&"object"==typeof t&&!k.has(r)){const e=t[r];return{key:r,pattern:e,searcher:y(e,s)}}let c={children:[],operator:r};return i.forEach(s=>{const i=t[s];e(i)&&i.forEach(e=>{c.children.push(n(e))})}),c};return t[M.AND]&&t[M.OR]||(t={[M.AND]:Object.keys(t).map(e=>({[e]:t[e]}))}),n(t)}(i,this.options);const{keys:s,list:r}=this._index,c={};r.forEach(e=>{let{$:i,i:r}=e;if(!n(i))return;const o=e=>{if(!e.children){const{key:t,searcher:n}=e,r=s.indexOf(t),c=i[r];return this._findMatches({key:t,value:c,searcher:n})}{const t=e.operator;let s=[];for(let n=0;n<e.children.length;n+=1){let c=e.children[n],h=o(c);if(h&&h.length)s.push({idx:r,item:i,matches:h});else if(t===M.AND){s.length=0;break}}s.length&&(c[r]||(c[r]={idx:r,item:i,matches:[]},h.push(c[r])),s.forEach(e=>{c[r].matches.push(...e.matches)}))}};o(t)})}return function(e,t){e.forEach(e=>{let s=1;e.matches.forEach(e=>{const{key:n,norm:i}=e,r=t.get(n,"weight")||-1,c=r>-1?r:1,h=0===e.score&&r>-1?Number.EPSILON:e.score;s*=Math.pow(h,c*i)}),e.score=s})}(h,this._keyStore),d&&h.sort(f),s(c)&&c>-1&&(h=h.slice(0,c)),function(e,t,{includeMatches:s=r.includeMatches,includeScore:n=r.includeScore}={}){const i=[];s&&i.push(l);n&&i.push(u);return e.map(e=>{const{idx:s}=e,n={item:t[s],refIndex:s};return i.length&&i.forEach(t=>{t(e,n)}),n})}(h,this._list,{includeMatches:o,includeScore:a})}_searchStringArrayWith(e){const{list:t}=this._index,{includeMatches:s}=this.options,i=[];return t.forEach(t=>{let{v:r,i:c,n:h}=t;if(!n(r))return;let o=e.searchIn(t);const{isMatch:a,score:l}=o;if(!a)return;let u={score:l,value:r,norm:h};s&&(u.indices=o.matchedIndices),i.push({item:r,idx:c,matches:[u]})}),i}_searchLogicalWith({key:e,searcher:t}){const s=[],{keys:i,list:r}=this._index,c=i.indexOf(e);return r.forEach(i=>{let{$:r,i:h}=i;if(!n(r))return;let o=this._findMatches({key:e,value:r[c],searcher:t});o.length&&s.push({idx:h,item:r,matches:o})}),s}_searchAllWith(e){const{keys:t,list:s}=this._index,i=[];return s.forEach(s=>{let{$:r,i:c}=s;if(!n(r))return;let h=[];t.forEach((t,s)=>{h.push(...this._findMatches({key:t,value:r[s],searcher:e}))}),h.length&&i.push({idx:c,item:r,matches:h})}),i}_findMatches({key:t,value:s,searcher:i}){let r=[];if(!n(s))return r;const{includeMatches:c}=this.options;if(e(s))s.forEach(e=>{const{v:s,i:h,n:o}=e;if(!n(s))return;let a=i.searchIn(e);const{isMatch:l,score:u}=a;if(!l)return;let d={score:u,key:t,value:s,idx:h,norm:o};c&&(d.indices=a.matchedIndices),r.push(d)});else{const{v:e,n:n}=s;let h=i.searchIn(s);const{isMatch:o,score:a}=h;if(!o)return[];let l={score:a,key:t,value:e,norm:n};c&&(l.indices=h.matchedIndices),r.push(l)}return r}}x.version="5.2.3",x.createIndex=h,x.config=r;export default x;