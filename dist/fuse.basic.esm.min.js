/**
 * Fuse.js v5.2.0-alpha.0 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
function t(t,{errors:e=0,currentLocation:s=0,expectedLocation:n=0,distance:i=100}){const r=e/t.length,o=Math.abs(n-s);return i?r+o/i:o?1:r}const e=t=>Array.isArray?Array.isArray(t):"[object Array]"===Object.prototype.toString.call(t),s=t=>"string"==typeof t,n=t=>"number"==typeof t,i=t=>null!=t;function r(t,r){let o=[],h=!1;const c=(t,r)=>{if(r){const l=r.indexOf(".");let a=r,u=null;-1!==l&&(a=r.slice(0,l),u=r.slice(l+1));const d=t[a];if(i(d))if(u||!s(d)&&!n(d))if(e(d)){h=!0;for(let t=0,e=d.length;t<e;t+=1)c(d[t],u)}else u&&c(d,u);else o.push((t=>null==t?"":(t=>{if("string"==typeof t)return t;let e=t+"";return"0"==e&&1/t==-1/0?"-0":e})(t))(d))}else o.push(t)};return c(t,r),h?o:o[0]}var o={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(t,e)=>t.score-e.score,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:r}};class h{constructor(t,e=({location:location=o.location,threshold:threshold=o.threshold,distance:distance=o.distance,includeMatches:includeMatches=o.includeMatches,findAllMatches:findAllMatches=o.findAllMatches,minMatchCharLength:minMatchCharLength=o.minMatchCharLength,isCaseSensitive:isCaseSensitive=o.isCaseSensitive}={})){if(this.options=e,t.length>32)throw new Error("Pattern length exceeds max of 32.");this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.patternAlphabet=function(t){let e={},s=t.length;for(let n=0;n<s;n+=1)e[t.charAt(n)]=0;for(let n=0;n<s;n+=1)e[t.charAt(n)]|=1<<s-n-1;return e}(this.pattern)}searchIn(t){let e=t.$;return this.searchInString(e)}searchInString(e){const{isCaseSensitive:s,includeMatches:n}=this.options;if(s||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return n&&(t.matchedIndices=[[0,e.length-1]]),t}const{location:i,distance:r,threshold:h,findAllMatches:c,minMatchCharLength:l}=this.options;return function(e,s,n,{location:i=o.location,distance:r=o.distance,threshold:h=o.threshold,findAllMatches:c=o.findAllMatches,minMatchCharLength:l=o.minMatchCharLength,includeMatches:a=o.includeMatches}={}){const u=s.length,d=e.length,f=Math.max(0,Math.min(i,d));let g=h,p=e.indexOf(s,f);const y=[];for(let t=0;t<d;t+=1)y[t]=0;if(-1!==p){let n=t(s,{errors:0,currentLocation:p,expectedLocation:f,distance:r});if(g=Math.min(n,g),p=e.lastIndexOf(s,f+u),-1!==p){let e=t(s,{errors:0,currentLocation:p,expectedLocation:f,distance:r});g=Math.min(e,g)}}p=-1;let m=[],M=1,x=u+d;const _=1<<(u<=31?u-1:30);for(let i=0;i<u;i+=1){let o=0,h=x;for(;o<h;){t(s,{errors:i,currentLocation:f+h,expectedLocation:f,distance:r})<=g?o=h:x=h,h=Math.floor((x-o)/2+o)}x=h;let l=Math.max(1,f-h+1),a=c?d:Math.min(f+h,d)+u,k=Array(a+2);k[a+1]=(1<<i)-1;for(let o=a;o>=l;o-=1){let h=o-1,c=n[e.charAt(h)];if(c&&(y[h]=1),k[o]=(k[o+1]<<1|1)&c,0!==i&&(k[o]|=(m[o+1]|m[o])<<1|1|m[o+1]),k[o]&_&&(M=t(s,{errors:i,currentLocation:h,expectedLocation:f,distance:r}),M<=g)){if(g=M,p=h,p<=f)break;l=Math.max(1,2*f-p)}}if(t(s,{errors:i+1,currentLocation:f,expectedLocation:f,distance:r})>g)break;m=k}let k={isMatch:p>=0,score:M||.001};return a&&(k.matchedIndices=function(t=[],e=1){let s=[],n=-1,i=-1,r=0;for(let o=t.length;r<o;r+=1){let o=t[r];o&&-1===n?n=r:o||-1===n||(i=r-1,i-n+1>=e&&s.push([n,i]),n=-1)}return t[r-1]&&r-n>=e&&s.push([n,r-1]),s}(y,l)),k}(e,this.pattern,this.patternAlphabet,{location:i,distance:r,threshold:h,findAllMatches:c,minMatchCharLength:l,includeMatches:n})}}function c(t,{n:e=3,pad:s=!0,sort:n=!1}){let i=[];if(null==t)return i;t=t.toLowerCase(),s&&(t=` ${t} `);let r=t.length-e+1;if(r<1)return i;for(;r--;)i[r]=t.substr(r,e);return n&&i.sort((t,e)=>t==e?0:t<e?-1:1),i}function l(t,n,{getFn:o=r,ngrams:h=!1}={}){let l=[];if(s(n[0]))for(let t=0,e=n.length;t<e;t+=1){const e=n[t];if(i(e)){let s={$:e,idx:t};h&&(s.ng=c(e,{sort:!0})),l.push(s)}}else{const r=t.length;for(let a=0,u=n.length;a<u;a+=1){let u=n[a],d={idx:a,$:{}};for(let n=0;n<r;n+=1){let r=t[n],l=o(u,r);if(i(l))if(e(l)){let t=[];const n=[{arrayIndex:-1,value:l}];for(;n.length;){const{arrayIndex:r,value:o}=n.pop();if(i(o))if(s(o)){let e={$:o,idx:r};h&&(e.ng=c(o,{sort:!0})),t.push(e)}else if(e(o))for(let t=0,e=o.length;t<e;t+=1)n.push({arrayIndex:t,value:o[t]})}d.$[r]=t}else{let t={$:l};h&&(t.ng=c(l,{sort:!0})),d.$[r]=t}}l.push(d)}}return l}class a{constructor(t){if(this._keys={},this._keyNames=[],this._length=t.length,t.length&&s(t[0]))for(let e=0;e<this._length;e+=1){const s=t[e];this._keys[s]={weight:1},this._keyNames.push(s)}else{let e=0;for(let s=0;s<this._length;s+=1){const n=t[s];if(!Object.prototype.hasOwnProperty.call(n,"name"))throw new Error('Missing "name" property in key object');const i=n.name;if(this._keyNames.push(i),!Object.prototype.hasOwnProperty.call(n,"weight"))throw new Error('Missing "weight" property in key object');const r=n.weight;if(r<=0||r>=1)throw new Error('"weight" property in key must be in the range of (0, 1)');this._keys[i]={weight:r},e+=r}for(let t=0;t<this._length;t+=1){const s=this._keyNames[t],n=this._keys[s].weight;this._keys[s].weight=n/e}}}get(t,e){return this._keys[t]?this._keys[t][e]:-1}keys(){return this._keyNames}count(){return this._length}toJSON(){return JSON.stringify(this._keys)}}function u(t,e){const s=t.matches;if(e.matches=[],i(s))for(let t=0,n=s.length;t<n;t+=1){let n=s[t];if(!i(n.indices)||0===n.indices.length)continue;let r={indices:n.indices,value:n.value};n.key&&(r.key=n.key),n.idx>-1&&(r.refIndex=n.idx),e.matches.push(r)}}function d(t,e){e.score=t.score}const f=[];class g{constructor(t,e={},s=null){this.options={...o,...e},this._processKeys(this.options.keys),this.setCollection(t,s)}static register(...t){f.push(...t)}setCollection(t,e=null){this.list=t,this.listIsStringArray=s(t[0]),e?this.setIndex(e):this.setIndex(this._createIndex())}setIndex(t){this._indexedList=t}_processKeys(t){this._keyStore=new a(t)}_createIndex(){return l(this._keyStore.keys(),this.list,{getFn:this.options.getFn})}search(t,e={limit:!1}){const{shouldSort:s}=this.options;let i=null;for(let e=0,s=f.length;e<s;e+=1){let s=f[e];if(s.condition(t,this.options)){i=new s(t,this.options);break}}i||(i=new h(t,this.options));let r=this._searchUsing(i);return this._computeScore(r),s&&this._sort(r),e.limit&&n(e.limit)&&(r=r.slice(0,e.limit)),this._format(r)}_searchUsing(t){const s=this._indexedList,n=[],{includeMatches:r}=this.options;if(this.listIsStringArray)for(let e=0,o=s.length;e<o;e+=1){let o=s[e],{$:h,idx:c}=o;if(!i(h))continue;let l=t.searchIn(o);const{isMatch:a,score:u}=l;if(!a)continue;let d={score:u,value:h};r&&(d.indices=l.matchedIndices),n.push({item:h,idx:c,matches:[d]})}else{const o=this._keyStore.keys(),h=this._keyStore.count();for(let c=0,l=s.length;c<l;c+=1){let{$:l,idx:a}=s[c];if(!i(l))continue;let u=[];for(let s=0;s<h;s+=1){let n=o[s],h=l[n];if(i(h))if(e(h))for(let e=0,s=h.length;e<s;e+=1){let s=h[e],o=s.$,c=s.idx;if(!i(o))continue;let l=t.searchIn(s);const{isMatch:a,score:d}=l;if(!a)continue;let f={score:d,key:n,value:o,idx:c};r&&(f.indices=l.matchedIndices),u.push(f)}else{let e=h.$,s=t.searchIn(h);const{isMatch:i,score:o}=s;if(!i)continue;let c={score:o,key:n,value:e};r&&(c.indices=s.matchedIndices),u.push(c)}}u.length&&n.push({idx:a,item:l,matches:u})}}return n}_computeScore(t){for(let e=0,s=t.length;e<s;e+=1){const s=t[e],n=s.matches,i=n.length;let r=1;for(let t=0;t<i;t+=1){const e=n[t],s=e.key,i=this._keyStore.get(s,"weight"),o=i>-1?i:1,h=0===e.score&&i>-1?Number.EPSILON:e.score;r*=Math.pow(h,o)}s.score=r}}_sort(t){t.sort(this.options.sortFn)}_format(t){const e=[],{includeMatches:s,includeScore:n}=this.options;let i=[];s&&i.push(u),n&&i.push(d);for(let s=0,n=t.length;s<n;s+=1){const n=t[s],{idx:r}=n,o={item:this.list[r],refIndex:r};if(i.length)for(let t=0,e=i.length;t<e;t+=1)i[t](n,o);e.push(o)}return e}}g.version="5.2.0-alpha.0",g.createIndex=l,g.config=o;export default g;