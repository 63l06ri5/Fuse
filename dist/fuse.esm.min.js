/**
 * Fuse.js v5.2.3 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
const t=t=>Array.isArray?Array.isArray(t):"[object Array]"===Object.prototype.toString.call(t),e=t=>"string"==typeof t,s=t=>"number"==typeof t,n=t=>null!=t,i=t=>!t.trim().length;var r={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(t,e)=>t.score===e.score?t.idx<e.idx?-1:1:t.score<e.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(i,r){let c=[],h=!1;const a=(i,r)=>{if(r){const o=r.indexOf(".");let l=r,u=null;-1!==o&&(l=r.slice(0,o),u=r.slice(o+1));const d=i[l];if(n(d))if(u||!e(d)&&!s(d))if(t(d)){h=!0;for(let t=0,e=d.length;t<e;t+=1)a(d[t],u)}else u&&a(d,u);else c.push((t=>null==t?"":(t=>{if("string"==typeof t)return t;let e=t+"";return"0"==e&&1/t==-1/0?"-0":e})(t))(d))}else c.push(i)};return a(i,r),h?c:c[0]}}};function c(t,{errors:e=0,currentLocation:s=0,expectedLocation:n=0,distance:i=r.distance}={}){const c=e/t.length,h=Math.abs(n-s);return i?c+h/i:h?1:c}function h(t,e,s,{location:n=r.location,distance:i=r.distance,threshold:h=r.threshold,findAllMatches:a=r.findAllMatches,minMatchCharLength:o=r.minMatchCharLength,includeMatches:l=r.includeMatches}={}){if(e.length>32)throw new Error("Pattern length exceeds max of 32.");const u=e.length,d=t.length,f=Math.max(0,Math.min(n,d));let g=h,p=f;const M=[];if(l)for(let t=0;t<d;t+=1)M[t]=0;let m;for(;(m=t.indexOf(e,p))>-1;){let t=c(e,{currentLocation:m,expectedLocation:f,distance:i});if(g=Math.min(t,g),p=m+u,l){let t=0;for(;t<u;)M[m+t]=1,t+=1}}p=-1;let x=[],y=1,k=u+d;const S=1<<(u<=31?u-1:30);for(let n=0;n<u;n+=1){let r=0,h=k;for(;r<h;){c(e,{errors:n,currentLocation:f+h,expectedLocation:f,distance:i})<=g?r=h:k=h,h=Math.floor((k-r)/2+r)}k=h;let o=Math.max(1,f-h+1),m=a?d:Math.min(f+h,d)+u,v=Array(m+2);v[m+1]=(1<<n)-1;for(let r=m;r>=o;r-=1){let h=r-1,a=s[t.charAt(h)];if(a&&l&&(M[h]=1),v[r]=(v[r+1]<<1|1)&a,0!==n&&(v[r]|=(x[r+1]|x[r])<<1|1|x[r+1]),v[r]&S&&(y=c(e,{errors:n,currentLocation:h,expectedLocation:f,distance:i}),y<=g)){if(g=y,p=h,p<=f)break;o=Math.max(1,2*f-p)}}if(c(e,{errors:n+1,currentLocation:f,expectedLocation:f,distance:i})>g)break;x=v}let v={isMatch:p>=0,score:y||.001};return l&&(v.matchedIndices=function(t=[],e=r.minMatchCharLength){let s=[],n=-1,i=-1,c=0;for(let r=t.length;c<r;c+=1){let r=t[c];r&&-1===n?n=c:r||-1===n||(i=c-1,i-n+1>=e&&s.push([n,i]),n=-1)}return t[c-1]&&c-n>=e&&s.push([n,c-1]),s}(M,o)),v}function a(t){let e={},s=t.length;for(let n=0;n<s;n+=1)e[t.charAt(n)]=0;for(let n=0;n<s;n+=1)e[t.charAt(n)]|=1<<s-n-1;return e}class o{constructor(t,{location:e=r.location,threshold:s=r.threshold,distance:n=r.distance,includeMatches:i=r.includeMatches,findAllMatches:c=r.findAllMatches,minMatchCharLength:h=r.minMatchCharLength,isCaseSensitive:o=r.isCaseSensitive}={}){this.options={location:e,threshold:s,distance:n,includeMatches:i,findAllMatches:c,minMatchCharLength:h,isCaseSensitive:o},this.pattern=o?t:t.toLowerCase(),this.chunks=[];let l=0;for(;l<this.pattern.length;){let t=this.pattern.substring(l,l+32);this.chunks.push({pattern:t,alphabet:a(t)}),l+=32}}searchIn(t){let e=t.v;return this.searchInString(e)}searchInString(t){const{isCaseSensitive:e,includeMatches:s}=this.options;if(e||(t=t.toLowerCase()),this.pattern===t){let e={isMatch:!0,score:0};return s&&(e.matchedIndices=[[0,t.length-1]]),e}const{location:n,distance:i,threshold:r,findAllMatches:c,minMatchCharLength:a}=this.options;let o=[],l=0,u=!1;for(let e=0,d=this.chunks.length;e<d;e+=1){let{pattern:d,alphabet:f}=this.chunks[e],g=h(t,d,f,{location:n+32*e,distance:i,threshold:r,findAllMatches:c,minMatchCharLength:a,includeMatches:s});const{isMatch:p,score:M,matchedIndices:m}=g;p&&(u=!0),l+=M,p&&m&&(o=[...o,...m])}let d={isMatch:u,score:u?l/this.chunks.length:1};return u&&s&&(d.matchedIndices=o),d}}class l{constructor(t){this.pattern=t}static isMultiMatch(t){return u(t,this.multiRegex)}static isSingleMatch(t){return u(t,this.singleRegex)}search(){}}function u(t,e){const s=t.match(e);return s?s[1]:null}class d extends l{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let e,s=0;const n=[],i=this.pattern.length;for(;(e=t.indexOf(this.pattern,s))>-1;)s=e+i,n.push([e,s-1]);const r=!!n.length;return{isMatch:r,score:r?1:0,matchedIndices:n}}}class f extends l{constructor(t,{location:e=r.location,threshold:s=r.threshold,distance:n=r.distance,includeMatches:i=r.includeMatches,findAllMatches:c=r.findAllMatches,minMatchCharLength:h=r.minMatchCharLength,isCaseSensitive:a=r.isCaseSensitive}={}){super(t),this._bitapSearch=new o(t,{location:e,threshold:s,distance:n,includeMatches:i,findAllMatches:c,minMatchCharLength:h,isCaseSensitive:a})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchInString(t)}}const g=[d,class extends l{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const e=t.startsWith(this.pattern);return{isMatch:e,score:e?0:1,matchedIndices:[0,this.pattern.length-1]}}},class extends l{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const e=!t.startsWith(this.pattern);return{isMatch:e,score:e?0:1,matchedIndices:[0,t.length-1]}}},class extends l{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const e=!t.endsWith(this.pattern);return{isMatch:e,score:e?0:1,matchedIndices:[0,t.length-1]}}},class extends l{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const e=t.endsWith(this.pattern);return{isMatch:e,score:e?0:1,matchedIndices:[t.length-this.pattern.length,t.length-1]}}},class extends l{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const e=-1===t.indexOf(this.pattern);return{isMatch:e,score:e?0:1,matchedIndices:[0,t.length-1]}}},f],p=g.length,M=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;const m=new Set([f.type,d.type]);const x=/[^ ]+/g;function y(s,c,{getFn:h=r.getFn}={}){let a=[],o=function(t=3){const e=new Map;return{get(s){const n=s.match(x).length;if(e.has(n))return e.get(n);const i=parseFloat((1/Math.sqrt(n)).toFixed(t));return e.set(n,i),i},clear(){e.clear()}}}(3);return e(c[0])?c.forEach((t,e)=>{if(!n(t)||i(t))return;let s={v:t,i:e,n:o.get(t)};a.push(s)}):c.forEach((r,c)=>{let l={i:c,$:{}};s.forEach((s,c)=>{let a=h(r,s);if(n(a))if(t(a)){let s=[];const r=[{nestedArrIndex:-1,value:a}];for(;r.length;){const{nestedArrIndex:c,value:h}=r.pop();if(n(h))if(e(h)&&!i(h)){let t={v:h,i:c,n:o.get(h)};s.push(t)}else t(h)&&h.forEach((t,e)=>{r.push({nestedArrIndex:e,value:t})})}l.$[c]=s}else if(!i(a)){let t={v:a,n:o.get(a)};l.$[c]=t}}),a.push(l)}),o.clear(),{keys:s,list:a}}const k=Object.prototype.hasOwnProperty;class S{constructor(t){this._keys={},this._keyNames=[];const s=t.length;if(t.length&&e(t[0]))for(let e=0;e<s;e+=1){const s=t[e];this._keys[s]={weight:1},this._keyNames.push(s)}else{let e=0;for(let n=0;n<s;n+=1){const s=t[n];let i={};if(!k.call(s,"name"))throw new Error('Missing "name" property in key object');const r=s.name;if(this._keyNames.push(r),!k.call(s,"weight"))throw new Error('Missing "weight" property in key object');const c=s.weight;if(c<=0||c>=1)throw new Error('"weight" property in key must be in the range of (0, 1)');i.weight=c,k.call(s,"threshold")&&(i.threshold=s.threshold),this._keys[r]=i,e+=c}for(let t=0;t<s;t+=1)this._keys[this._keyNames[t]].weight/=e}}get(t,e){return this._keys[t]&&this._keys[t][e]}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}function v(t,e){const s=t.matches;if(e.matches=[],n(s))for(let t=0,i=s.length;t<i;t+=1){let i=s[t];if(!n(i.indices)||0===i.indices.length)continue;const{indices:r,value:c}=i;let h={indices:r,value:c};i.key&&(h.key=i.key),i.idx>-1&&(h.refIndex=i.idx),e.matches.push(h)}}function _(t,e){e.score=t.score}const A=[];function C(t,e){for(let s=0,n=A.length;s<n;s+=1){let n=A[s];if(n.condition(t,e))return new n(t,e)}return new o(t,e)}const w={AND:"$and",OR:"$or"},L=new Set(Object.values(w));class I{constructor(t,e={},s){this.options={...r,...e},this._keyStore=new S(this.options.keys),this.setCollection(t,s)}setCollection(t,e){this._list=t,this._index=e||y(this._keyStore.keys(),this._list,{getFn:this.options.getFn})}search(i,{limit:c=-1}={}){let h=[];const{includeMatches:a,includeScore:o,shouldSort:l,sortFn:u}=this.options;if(e(i)){const t=C(i,this.options);h=e(this._list[0])?this._searchStringArrayWith(t):this._searchAllWith(t)}else{let e=function(e,s){const n=e=>{const i=Object.keys(e),r=i[0];if(!t(e)&&"object"==typeof e&&!L.has(r)){const t=e[r];return{key:r,pattern:t,searcher:C(t,s)}}let c={children:[],operator:r};return i.forEach(s=>{const i=e[s];t(i)&&i.forEach(t=>{c.children.push(n(t))})}),c};return e[w.AND]&&e[w.OR]||(e={[w.AND]:Object.keys(e).map(t=>({[t]:e[t]}))}),n(e)}(i,this.options);const{keys:s,list:r}=this._index,c={};r.forEach(t=>{let{$:i,i:r}=t;if(!n(i))return;const a=t=>{if(!t.children){const{key:e,searcher:n}=t,r=s.indexOf(e),c=i[r];return this._findMatches({key:e,value:c,searcher:n})}{const e=t.operator;let s=[];for(let n=0;n<t.children.length;n+=1){let c=t.children[n],h=a(c);if(h&&h.length)s.push({idx:r,item:i,matches:h});else if(e===w.AND){s.length=0;break}}s.length&&(c[r]||(c[r]={idx:r,item:i,matches:[]},h.push(c[r])),s.forEach(t=>{c[r].matches.push(...t.matches)}))}};a(e)})}return function(t,e){t.forEach(t=>{let s=1;t.matches.forEach(t=>{const{key:n,norm:i}=t,r=e.get(n,"weight")||-1,c=r>-1?r:1,h=0===t.score&&r>-1?Number.EPSILON:t.score;s*=Math.pow(h,c*i)}),t.score=s})}(h,this._keyStore),l&&h.sort(u),s(c)&&c>-1&&(h=h.slice(0,c)),function(t,e,{includeMatches:s=r.includeMatches,includeScore:n=r.includeScore}={}){const i=[];s&&i.push(v);n&&i.push(_);return t.map(t=>{const{idx:s}=t,n={item:e[s],refIndex:s};return i.length&&i.forEach(e=>{e(t,n)}),n})}(h,this._list,{includeMatches:a,includeScore:o})}_searchStringArrayWith(t){const{list:e}=this._index,{includeMatches:s}=this.options,i=[];return e.forEach(e=>{let{v:r,i:c,n:h}=e;if(!n(r))return;let a=t.searchIn(e);const{isMatch:o,score:l}=a;if(!o)return;let u={score:l,value:r,norm:h};s&&(u.indices=a.matchedIndices),i.push({item:r,idx:c,matches:[u]})}),i}_searchLogicalWith({key:t,searcher:e}){const s=[],{keys:i,list:r}=this._index,c=i.indexOf(t);return r.forEach(i=>{let{$:r,i:h}=i;if(!n(r))return;let a=this._findMatches({key:t,value:r[c],searcher:e});a.length&&s.push({idx:h,item:r,matches:a})}),s}_searchAllWith(t){const{keys:e,list:s}=this._index,i=[];return s.forEach(s=>{let{$:r,i:c}=s;if(!n(r))return;let h=[];e.forEach((e,s)=>{h.push(...this._findMatches({key:e,value:r[s],searcher:t}))}),h.length&&i.push({idx:c,item:r,matches:h})}),i}_findMatches({key:e,value:s,searcher:i}){let r=[];if(!n(s))return r;const{includeMatches:c}=this.options;if(t(s))s.forEach(t=>{const{v:s,i:h,n:a}=t;if(!n(s))return;let o=i.searchIn(t);const{isMatch:l,score:u}=o;if(!l)return;let d={score:u,key:e,value:s,idx:h,norm:a};c&&(d.indices=o.matchedIndices),r.push(d)});else{const{v:t,n:n}=s;let h=i.searchIn(s);const{isMatch:a,score:o}=h;if(!a)return[];let l={score:o,key:e,value:t,norm:n};c&&(l.indices=h.matchedIndices),r.push(l)}return r}}!function(...t){A.push(...t)}(class{constructor(t,{isCaseSensitive:e=r.isCaseSensitive,includeMatches:s=r.includeMatches,minMatchCharLength:n=r.minMatchCharLength,findAllMatches:i=r.findAllMatches,location:c=r.location,threshold:h=r.threshold,distance:a=r.distance}={}){this.query=null,this.options={isCaseSensitive:e,includeMatches:s,minMatchCharLength:n,findAllMatches:i,location:c,threshold:h,distance:a},this.pattern=e?t:t.toLowerCase(),this.query=function(t,e={}){return t.split("|").map(t=>{let s=t.trim().split(M).filter(t=>t&&!!t.trim()),n=[];for(let t=0,i=s.length;t<i;t+=1){const i=s[t];let r=!1,c=-1;for(;!r&&++c<p;){const t=g[c];let s=t.isMultiMatch(i);s&&(n.push(new t(s,e)),r=!0)}if(!r)for(c=-1;++c<p;){const t=g[c];let s=t.isSingleMatch(i);if(s){n.push(new t(s,e));break}}}return n})}(this.pattern,this.options)}static condition(t,e){return e.useExtendedSearch}searchIn(t){const e=this.query;if(!e)return{isMatch:!1,score:1};let s=t.v;const{includeMatches:n,isCaseSensitive:i}=this.options;s=i?s:s.toLowerCase();let r=0,c=[],h=0;for(let t=0,i=e.length;t<i;t+=1){const i=e[t];c.length=0,r=0;for(let t=0,e=i.length;t<e;t+=1){const e=i[t],{isMatch:a,matchedIndices:o,score:l}=e.search(s);if(!a){h=0,r=0,c.length=0;break}if(r+=1,h+=l,n){const t=e.constructor.type;m.has(t)?c=[...c,...o]:c.push(o)}}if(r){let t={isMatch:!0,score:h/r};return n&&(t.matchedIndices=c),t}}return{isMatch:!1,score:1}}}),I.version="5.2.3",I.createIndex=y,I.config=r;export default I;